# 版本管理设计文档

## 版本号生成策略

### 核心原则

版本号生成**基于当前版本**，而不是历史所有版本的最大值。这样可以更符合用户的预期，实现真正的版本分支管理。

### 版本号格式

`major.minor` 格式，例如：`1.0`, `1.1`, `2.0`

- **Major（主版本）**: 重大变更，不兼容的修改
- **Minor（次版本）**: 向后兼容的功能性新增或修改

---

## 场景示例

### 场景 1：线性开发（最常见）

**初始状态**:
- 版本历史: `1.0` (current)
- 当前版本: `1.0`

**操作**: 创建新版本 → Minor
- **结果**: `1.1` ✅
- **说明**: 基于当前 1.0，minor +1

**操作**: 继续创建 → Minor
- **结果**: `1.2` ✅
- **说明**: 基于当前 1.1，minor +1

**操作**: 创建重大更新 → Major
- **结果**: `2.0` ✅
- **说明**: 基于当前 1.2，major +1，minor 重置为 0

---

### 场景 2：恢复到旧版本后继续开发

**初始状态**:
- 版本历史: `1.0`, `1.1`, `1.2`, `2.0`
- 当前版本: `1.1` (用户恢复到了旧版本)

**操作**: 创建新版本 → Minor
- **期望**: `1.2` (基于 1.1 的 minor +1)
- **冲突**: `1.2` 已存在！
- **自动解决**: 继续递增 → `1.3` ✅
- **说明**: 自动跳过已存在的版本号

**操作**: 创建重大更新 → Major
- **期望**: `2.0` (基于 1.1 的 major +1)
- **冲突**: `2.0` 已存在！
- **自动解决**: 继续递增 → `3.0` ✅
- **说明**: 自动跳过已存在的版本号

---

### 场景 3：复杂的版本分支

**初始状态**:
- 版本历史: `1.0`, `1.1`, `2.0`, `2.1`, `3.0`
- 当前版本: `1.1`

**操作**: Minor
- 计算: `1.1` → `1.2`
- 检查: `1.2` 不存在
- **结果**: `1.2` ✅

**操作**: 切换到 `2.1`，然后 Minor
- 计算: `2.1` → `2.2`
- 检查: `2.2` 不存在
- **结果**: `2.2` ✅

**操作**: 切换到 `2.2`，然后 Major
- 计算: `2.2` → `3.0`
- 检查: `3.0` 已存在
- 继续: `4.0` 不存在
- **结果**: `4.0` ✅

---

## 代码实现逻辑

```typescript
function generateVersionNumber(
  versions: Version[],
  currentVersionId: string,
  type: 'major' | 'minor'
): string {
  // 1. 找到当前版本
  const current = versions.find(v => v.id === currentVersionId);
  const [currentMajor, currentMinor] = current.versionNumber.split('.');

  // 2. 计算期望的新版本号
  let newMajor, newMinor;
  if (type === 'major') {
    newMajor = currentMajor + 1;
    newMinor = 0;  // Major 升级时，minor 重置为 0
  } else {
    newMajor = currentMajor;
    newMinor = currentMinor + 1;
  }

  // 3. 检查版本号冲突，自动递增直到找到可用的版本号
  let newVersion = `${newMajor}.${newMinor}`;
  const existing = new Set(versions.map(v => v.versionNumber));

  while (existing.has(newVersion)) {
    if (type === 'major') {
      newMajor++;
      newVersion = `${newMajor}.0`;
    } else {
      newMinor++;
      newVersion = `${newMajor}.${newMinor}`;
    }
  }

  return newVersion;
}
```

---

## 用户界面说明

### 版本创建对话框

用户在保存修改时，如果内容有变化，会弹出版本创建对话框：

1. **Change Note（更改说明）**
   - 输入框：描述这次修改的内容
   - 示例：
     - "优化了提示词结构"
     - "修复了变量引用错误"
     - "重大重构：改用新的模板格式"

2. **Version Type（版本类型）**
   - **Minor（次版本）**: 小改动，向后兼容
     - 示例：修复错误、优化措辞、添加变量
     - 版本号变化：`1.2` → `1.3`

   - **Major（主版本）**: 大改动，重大变更
     - 示例：完全重写、改变结构、不兼容的修改
     - 版本号变化：`1.2` → `2.0`

---

## 版本恢复逻辑

恢复版本时，**直接切换** `currentVersionId` 指向目标版本，不创建新版本记录。

**示例**:
- 当前版本: `2.0`
- 恢复到: `1.1`
- 结果: `currentVersionId` 指向 `1.1`，版本历史不变

---

## 设计优势

1. **符合直觉**: 用户期望基于当前版本创建新版本
2. **避免混乱**: 不会无限线性递增，版本号有意义
3. **自动处理冲突**: 遇到已存在的版本号自动递增
4. **灵活分支**: 可以从任意历史版本继续开发
5. **真实版本管理**: 类似 Git 的分支概念

---

## 与旧逻辑的对比

### 旧逻辑（❌ 问题）
```
版本历史: 1.0, 1.1, 1.2
当前版本: 1.0

创建 Minor → 1.3  ❌ 不符合预期，跳过了 1.1, 1.2
创建 Major → 2.0  ✅ 正确
```

### 新逻辑（✅ 正确）
```
版本历史: 1.0, 1.1, 1.2
当前版本: 1.0

创建 Minor → 1.1（冲突）→ 1.2（冲突）→ 1.3  ✅ 自动解决冲突
创建 Major → 2.0  ✅ 基于当前版本
```

---

## 注意事项

1. **版本号不可编辑**: 自动生成，确保一致性
2. **版本不可删除**: 所有历史版本永久保留
3. **currentVersionId**: 始终指向用户当前使用的版本
4. **版本切换**: 使用 Restore 功能在不同版本间切换
